# Lab 6: Network Driver

> 终于到了最后一个lab。

## Introduction

本实验将基于网络接口卡实现一个驱动程序。该接口卡基于Intel 82540EM芯片（也被称为E1000）

## QEMU's virtual network

我们将使用QEMU的用户态网络栈，因为其不需要管理权限来运行。实验修改了makefile以开启QEMU用户态网络栈以及虚拟化的E1000网卡。

默认情况下，QEMU提供一个运行在IP地址10.0.2.2上的虚拟路由，并且会将JOS的IP地址设定为10.0.2.15。为了简化实验，我们将这些默认内容硬编码到了服务端中，位于net/ns.h处。

尽管QEMU的虚拟网络允许JOS随意连接Internet，但是在QEMU内部运行的虚拟网络以外，JOS的IP没有任何意义（QEMU充当了NAT），因此我们不能直接连接到JOS内部运行的服务器，甚至不能从运行QEMU的主机上连接。为了解决这个问题，我们配置QEMU使其运行的服务器使用主机的某个端口，该服务器只是连接到JOS中的某个端口并且在主机和虚拟网络间传输数据。

实验将会在JOS的7号端口（echo）和80号端口（http）运行服务器。

### Packet Inspection

makefile还配置了QEMU的网络栈来记载所有的进出报文，报文保存在lab路径下的qemu.pcap中。

### Debugging the E1000

使用模拟的硬件是很幸运的，因为E1000在软件中运行，模拟的E1000可以以用户可读的形式上报其内部状态和任何产生的问题。E1000可以生成大量的调试输出，因此你应当启用特定的日志频道。以下频道是可能有帮助的：

| Flag      | 含义                       |
| --------- | -------------------------- |
| tx        | 记录报文传输操作           |
| txerr     | 记录传输环路错误           |
| rx        | 记录RCTL变化               |
| rxfilter  | 记录入站报文的过滤         |
| rxerr     | 记录接收环路错误           |
| unknown   | 记录未知寄存器的读写       |
| eeprom    | 记录EEPROM的读             |
| interrupt | 记录中断和中断寄存器的变化 |

## The Network Server

从头编写网络堆栈是一项艰巨的任务。因此实验中使用lwIP，lwIP是开源的轻量级TCP/IP协议陶坚，其中包括了一个网络栈。实验中lwIP被视为黑盒，其实现了BSD套接字接口，并且有一个报文输入端口和一个报文输出端口。

网络服务器实际上是以下环境的组合体：
    - 核心网络服务器环境（包括了lwIP和套接字调用调度程序）
    - 输入环境
    - 输出环境
    - 计时器环境

### The Core Network Server Environment

核心网络服务器环境由套接字调用调度程序和lwIP本身组成。套接字调用调度程序实际上如同文件服务器一样工作。用户环境使用存根向套接字调用调度程序发送IPC信息。查看lib/nsipc.c将会发现我们使用了和发现文件服务器同样的方式来发现套接字调用调度程序：i386_init使用NS_TYPE_NS创建NS环境，因此我们可以扫描envs，寻找这个特殊的环境类型。对于每个用户环境的IPC，网络服务器中的调度程序调用由lwIP提供的适当的BSD套接字接口函数。

常规用户环境不直接使用nsipc_*的调用，而使用lib/sockets.c中的函数，这些函数提供了一个基于文件描述符的套接字API。因此，用户环境借助文件描述符来指定套接字，就像其指定磁盘上文件的方式一样。一些操作（如connect，accept等等）对套接字来说是特别的，但是读写关闭都是借助lib/fd.c中的普通文件描述符设备调度代码。如同文件服务器为所有打开的文件维护内部唯一的ID一样，lwIP也为所有打开的套接字生成唯一ID。在文件服务器和网络服务器中，我们使用存储在struct Fd中的信息，将每个环境的文件描述符映射到这些唯一的ID空间。

尽管文件服务器和网络服务器的IPC调度程序看起来一致，实际上还是有一个关键的区别。BSD套接字调用，像是accept和recv可以无限制地阻塞。如果调度器帮助lwIP执行其中的一个阻塞调用，调度器将会同样陷入阻塞状态，对于整个系统来说，同一时间只能存在一个未完成的网络调用。由于这种情况不可接受，所以网络服务器使用用户级线程来避免阻塞整个服务器环境。对于每个传入的IPC消息，调度器创建一个线程并在其中处理请求。如果线程阻塞，则只有该线程处于休眠状态，而其他线程继续运行。

作为核心网络环境的扩充，还有三个起到协助作用的环境。除了接受来自用户应用程序的消息之外，核心网络环境的分配器还会接收来自输入环境和计时器环境的消息。

### The Output Environment

当服务于用户环境套接字调用时，lwIP将生成网卡要传输的数据包，lwIP将使用NSREQ_OUTPUT IPC消息将每个要传输的报文发送到输出环境，IPC消息的页面参数中附加了这个报文。输出环境负责接收这些消息，并通过即将创建的系统调用接口将报文转发到设备驱动程序。

### The Input Environment

由网卡接收的报文需要被注入到lwIP。对于每个由设备驱动接收到的报文，输入环境将其从内核空间（借助内核系统调用）拉取出来，再使用NSREQ_INPUT IPC消息将报文发送到核心服务器环境。

报文输入的功能和核心网络环境是分离的，因为JOS使得同时接收IPC消息、轮询或等待来自设备驱动的报文变得困难。JOS中没有select系统调用来允许环境监视多个输入源以鉴别出准备好被处理的那个。

### The Timer Environment

计时器环境定期向核心网络服务器发送NSREQ_TIMER类型的消息，通知它计时器已经过期。lwIP使用来自该线程的计时器消息来实现各种网络超时。
