# Lab 5: File system, Spawn and Shell

## 介绍

本实验实现spawn，spawn是一个加载并运行磁盘上的可执行文件的库调用。然后完善内核和库使操作系统足以在控制台上运行一个shell。这些功能的实现需要文件系统，本实验介绍了一个简单的读写文件系统。

## File system preliminaries

将实现的文件系统比大多数现实的文件系统要简单得多，但是功能已经足够强大，可以提供基本的功能：创建、读取、写入、删除层次结构下的文件。目前我们开发的只是一个单用户的操作系统，有足够的保护能力以捕获bug，但是不足以在多个相互怀疑的用户间建立保护。因此我们的文件系统不支持UNIX中的文件所有权和文件权限。我们的文件系统目前也不支持硬链接、符号链接、时间戳，以及同大多数UNIX文件系统一样的特殊设备文件。

### On-Disk File System Structure

多数UNIX文件系统将可用磁盘空间划分成两个主要类型的区域：inode区和数据区。UNIX文件系统为每个文件分配一个inode；一个文件的inode保存了文件相关的关键元数据，例如其stat属性以及数据块的指针。数据区被划分成更大的数据块（通常为8KB或更大），文件系统在此处存放文件数据和目录元数据。目录项包括了文件名称和文件inode的指针；如果文件系统的多个目录项引用了一个文件的inode，则称该文件被硬链接。因为我们的文件系统不支持硬链接，我们不需要这个级别的间接寻址，因此可以简化：我们的文件系统不会用到inode，只将文件（或子目录）的元数据存储在描述该文件的唯一目录项中。

文件和目录逻辑上由一系列数据块组成，这些数据块在磁盘上可以是分散的，就像环境的虚拟地址控件的页可以分散在物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件中任意位置读写字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建、删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据，这意味着用户环境自身可以执行目录扫描操作而不需要以来文件系统上的附加的特殊调用。这种方法的缺点（同样也是现代UNIX的变体不支持该方法的原因）是，它使得应用程序依赖于目录元数据的格式，使更改文件系统的内部布局变得非常困难，除非修改、重新编译应用程序。

### Sectors and Blocks

大多数磁盘不能按字节粒度执行读写操作，而是以扇区为单位执行读写操作。在JOS中，每个扇区大小为512字节。文件系统实际上是以块为单位分配、使用磁盘存储的。注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是基础磁盘扇区大小的倍数。

UNIX xv6文件系统使用了512字节大小的块，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间价格低廉，且在更大的粒度上管理存储更有效率。我们的文件系统将使用4096的块大小，方便匹配处理器的页面大小。

### Superblocks

文件系统通常会在磁盘上“易于寻找”的地方（如磁盘开头和末尾处）保留一定数量的磁盘块，用以将*描述文件系统属性的元数据*作为一个整体，如块大小、磁盘大小、任何用来查找根目录的元数据、上次文件系统挂载的时间、文件系统上次出错的时间等等。这些特殊的块被称为超级块。

我们的文件系统将只会有一个超级块，它总是会位于磁盘的第一块。其布局是由inc/fs.h中顶一个struct Super定义的。第0块通常用于保存bootloader和分区表，因此文件系统通常不使用第一个磁盘块。许多真实的文件系统维护了多个超级块，这些块被复制到磁盘的多个宽空间区域中，一旦其中的一个块被破坏了或是磁盘媒介在该区域发生了错误，其他的超级块仍然可以被找到并用来访问文件系统。

### File Meta-data

我们的文件系统中描述文件的元数据布局位于inc/fs.h中的struct File。该元数据包括了文件的名称、大小、类型（常规文件或是目录）以及指向组成文件的块的指针。我们没有使用inode，因此元数据存储在磁盘上的目录项中。与大多数现实中的文件系统不同，我们使用这个单文件结构来表示文件元数据，这样它同时出现在磁盘和内存中。

struct File中的f_direct数组包含了存储文件前十个块（NDIRECT）的块号的空间，我们称其为文件的直接块。对于文件大小不大于40KB的小文件，这意味着所有文件的块编号将会直接保存在File结构本身中；对于较大的文件，我们需要一个地方来存储文件其余块号。因此对于任何大于40KB的文件，我们将分配一个额外的磁盘块，称其为文件的间接块，以容纳最多1024个额外的块号。因此，我们的文件系统最多支持1034个块，即刚好比4M字节多一点。为了支持更大的文件，现实的文件系统通常还支持双重间接块和三种间接块。

### Directories versus Regular Files

我们的文件系统里的File结构既可以表示一个常规文件也可以表示一个目录；这两种文件的类型通过File结构中的type字段进行区分。文件系统实际上以同种方式管理常规文件和目录文件，其将目录文件内容解释为一系列File结构，这些结构描述了目录下的文件和子目录。

JOS的文件系统中的超级块包含了一个File结构（位于Super结构体的root字段），其保存了文件系统根目录的元数据。这个目录文件的内容是一系列描述了文件系统根目录下的文件和目录的File结构。根目录下的任何子目录都可以包含表示更多表示子目录的File结构（译注：原文感觉啰嗦一些，实际上就是允许子目录递归）。

## The File System

本实验的目标不是要求实现整个文件系统，只需要实现将块读入块缓存并刷新返回磁盘、分配磁盘块、将文件偏移映射到磁盘块、再IPC接口中读写和打开。

### Disk Access

JOS中文件系统环境需要能够访问地盘，但是我们还没有在内核中实现任何磁盘访问功能。为了取代传统且复杂的操作系统策略（在内核中添加一个IDE磁盘驱动和必要的系统调用以允许文件系统访问它），我们将IDE磁盘驱动作为用户级文件系统环境的一部分。我们仍然需要稍微修改内核，以便进行设置，使得文件系统环境拥有实现磁盘基本访问本身所需要的特权。

依靠轮询在用户空间实现磁盘访问是很容易的。基于PIO（DMA前的早期IO方式，数据要通过CPU流向磁盘）的磁盘访问不需要使用磁盘中断。实现用户态的*中断驱动的*设备驱动程序是一种可行方法（L3和L4内核可以做到），但是由于内核必须实现设备中断并且分配到对应用户态环境中，因此这种方法实际上更为困难。

x86处理器在EFLAGS寄存器中使用IOPL位来决定保护模式代码是否允许执行特殊的设备IO指令，如IN和OUT指令。因为所有我们需要访问的IDE磁盘寄存器都位于x86的IO空间，而不是被内存映射，因此我们为了访问这些寄存器只需要给予文件系统环境以IO权限。实际上，EFLAGS中的IOPL位为内核提供了全有或全无的方法来确定用户代码是否可以访问IO空间。

### The Block Cache

在JOS文件系统中，将要借助处理器的虚拟内存系统实现一种简单的缓冲区cache。JOS文件系统将会被限制最多使用3GB大小的磁盘空间。我们从文件系统环境的地址空间保留一个大的固定的3GB区域（从0x10000000，即DISKMAP，到0xd0000000，即DISKMAP+DISKMAX），作为磁盘的内存映射版本。例如，磁盘块0被映射到虚拟地址0x10000000，块1被映射到虚拟地址0x10001000。

因为文件系统环境有其独立的虚拟地址空间，该空间独立于其他环境的虚拟地址空间，并且文件系统环境唯一需要做的就是实现文件访问，因此以这种方式保存大部分文件系统环境的地址空间是合理的。

当然，将整个磁盘读入到内存需要占用很长时间，因此我们将会实现一种请求分页的机制，在该机制下我们只为磁盘映射区分配页，再读取相关磁盘块以响应该区域的页错误。这样我们可以假设整个磁盘都位于内存中。

### The Block Bitmap

在fs_init设置了bitmap指针后，我们可以把bitmap视为封装的位数组，每一个元素表示磁盘上的一个块。

### File Operations

> 该部分借助已经提供的方法实现一些基本的读写操作

### The file system interface

现在需要使文件系统环境对其他环境可访问，以达到使用文件系统的目的。其他环境不能直接调用文件系统内的环境，因此我们将通过构建JOS的IPC机制之上的远程过程调用（RPC）抽象，来开放文件系统环境的访问。

```txt
        Regular env          FS env
    +---------------+   +---------------+
    |    read       |   |   file_read   |
    | (lib/fd.c)    |   |   (fs/fs.c)   |
....|.......|.......|...|.......^.......|....
    |       v       |   |       |       | RPC mechanism
    | devfile_read  |   | serve_read    |
    | (lib/file.c)  |   | (fs/serv.c)   |
    |       |       |   |       ^       |
    |       v       |   |       |       |
    |    fsipc      |   |    serve      |
    | (lib/file.c)  |   |   (fs/serv.c) |
    |       |       |   |       ^       |
    |       v       |   |       |       |
    |   ipc_send    |   |   ipc_recv    |
    |       |       |   |       ^       |
    +-------|-------+   +-------|-------+
            |                   |
            +-------------------+
```

如上图，虚线下方的内容展示了读请求从常规环境获取到文件系统环境的机制。一开始read就可以在任意文件描述符上工作，并分派适当的设备读函数，本例中为devfile_read。devfile_read实现了专门针对磁盘文件的读取。该函数和其他的devfile_*函数实现了文件系统操作的客户端，它们以大致相同的方式工作，在请求结构中绑定参数，调用fsipc发送IPC请求，然后解包并返回结果，fsipc函数只处理向服务器发送请求和接收应答的常见细节。

文件系统的服务端代码在server函数中无限循环以接受来自IPC的请求，分配请求到适当的处理函数，再通过IPC返回结果。此例中，serve将分配给serve_read，其将处理特定读请求的IPC细节部分，如解包请求结构并最终调用file_read来实际进行文件读取。

JOS的IPC机制允许环境发送一个32位的数并共享一个页（可选）。为了从客户端向服务端发送请求，我们使用这个32位数作为请求类型（即，文件系统服务端的RPC被编码，就如同syscall被编码一样），并将请求参数存储在通过IPC共享的页的union fsipc中。在客户端，我们通常在fsipcbuf共享页面；在服务端，我们将传入的请求页面映射到fsreq（0x0ffff000）。

服务端同样通过IPC将应答发回。我们使用32位数字作为函数的返回码。对于大多数RPC，这个数字就是其返回的全部内容。FSREQ_READ和FSREQ_STAT也是返回的数据，其被写入客户端发送来的请求页，该页不需要在响应IPC中被发送，因为客户端首先与文件系统服务器共享此页面。同样，在它的响应中，FSREQ_OPEN与客户端共享一个新的fd页面。我们将稍后返回到文件描述符页。

## Spawning Processes

JOS提供了spawn用来创建新环境，并从文件系统加载程序映像到环境中，然后启动子环境运行此映像，而后父进程独立于子进程继续运行。实际上spawn函数行为类似UNIX中的fork后紧跟一个exec以创建子进程。

我们实现了spawn而不是UNIX风格的exec，因为spawn更容易从用户空间实现“exokernel fashion”，而不用借助内核的特殊帮助。思考一下当你需要做什么才能在用户空间实现exec，确保你自己理解这其中的难点所在。

### Sharing library state across fork and spawn

UNIX的文件描述符是一个通用的概念，其还包括了管道、控制台IO等等。在JOS中，这些设备的每个类型都有对应的struct Dev，其指向了为该种设备实现的read/write/etc.函数。每个struct Fd表明了其设备类型，lib/fd.c中的大多数函数都为合适的struct Dev中的函数分配了操作。

lib/fd.c在每个应用环境的地址控件维护着**文件描述符表**区，该区域开始自FDTABLE。这个区域保留了等同于一个页大小（4KB）的地址空间用于存储应用程序可以同时打开的不超过MAXFD（目前为32）数量的文件描述符。在任何给定时间内，一个文件描述符表页*当且仅当相关的文件描述符处于使用状态时*被映射。每个文件描述符在FILEDATA的开始处还有一个可选的数据页，这个页可以被设备选择使用。

我们希望跨越fork和spawn共享文件描述符状态，但是文件描述符状态保存在用户空间内存里。现在，通过fork，内存将会被标记为写时复制，所以状态将会被复制而不是共享。（这意味着环境将只能在自己打开的文件中执行查找，同时管道也不能跨fork使用）。在spawn中，内存不会被复制而只是保留下来。（实际上派生环境以没有打开的文件描述符开始）

## The keyboard interface

为了使用shell，我们需要实现输入。QEMU已经显示我们写到CGA显示器和串口的内容，但到现在为止我们只在内核控制台接收了输入。在QEMU中，在图形窗口中键入的内容将作为键盘到JOS的输入，而控制台中键入的内容将作为串口上的字符出现。
