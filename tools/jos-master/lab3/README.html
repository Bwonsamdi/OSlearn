<!DOCTYPE html>
<!-- saved from url=(0064)file:///var/folders/4x/p752xljj6yvdxpx5v_qrtld40000gn/T/145.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>README</title></head><body><h1 id="report-for-lab3-shian-chen">Report for lab3, Shian Chen</h1>
<blockquote>
<p>all exercises finished </p>
<p>one challenge completed</p>
</blockquote>
<pre><code>make[1]: Leaving directory `/home/clann/lab3'
divzero: OK (5.4s) 
softint: OK (4.6s) 
badsegment: OK (4.6s) 
Part A score: 30/30

faultread: OK (4.6s) 
faultreadkernel: OK (4.6s) 
faultwrite: OK (4.6s) 
faultwritekernel: OK (4.6s) 
breakpoint: OK (4.6s) 
testbss: OK (4.7s) 
hello: OK (4.6s) 
buggyhello: OK (4.6s) 
buggyhello2: OK (4.6s) 
    (Old jos.out.buggyhello2 failure log removed)
evilhello: OK (4.6s) 
Part B score: 50/50

Score: 80/80
</code></pre>

<h1 id="part-a-user-environments-and-exception-handling">Part A: User Environments and Exception Handling</h1>
<h2 id="exercise-1">Exercise 1</h2>
<pre><code>Exercise 1. Modify mem_init() in kern/pmap.c to allocate and map the envs array. This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.
</code></pre>

<p>Kid's stuff. Just add the following code to <code>pmap.c</code>. </p>
<pre><code class="c">pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
...
envs = (struct Env *) boot_alloc(sizeof(struct Env) * NENV);
...
boot_map_region(kern_pgdir,
    UENVS,
    PTSIZE,
    PADDR(envs),
    PTE_U);
</code></pre>

<p>But unfortunately I failed in <code>check_page_free_list</code> due to my previous implementation of <code>page_init</code>:</p>
<pre><code class="c">void
page_init(void)
{
    size_t i;
    for (i = 1; i &lt; npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &amp;pages[i];
    }
    int med = (int)ROUNDUP(((char*)pages) + (sizeof(struct PageInfo) * npages) - 0xf0000000, PGSIZE)/PGSIZE;
    cprintf("%x\n", ((char*)pages) + (sizeof(struct PageInfo) * npages));
    cprintf("med=%d\n", med);
    for (i = med; i &lt; npages; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &amp;pages[i];
    }
}
</code></pre>

<p>I calculated the free physical pages using the end address of <code>pages</code>, but now it should be <code>envs</code>:</p>
<pre><code class="c">void
page_init(void)
{
    size_t i;
    for (i = 1; i &lt; npages_basemem; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &amp;pages[i];
    }
    int med = (int)ROUNDUP(((char*)envs) + (sizeof(struct Env) * NENV) - 0xf0000000, PGSIZE)/PGSIZE;
    cprintf("%x\n", ((char*)envs) + (sizeof(struct Env) * NENV));
    cprintf("med=%d\n", med);
    for (i = med; i &lt; npages; i++) {
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &amp;pages[i];
    }
}
</code></pre>

<p>And this finished the first exercise.</p>
<h2 id="exercise-2">Exercise 2</h2>
<pre><code>Exercise 2. In the file env.c, finish coding the following functions:

env_init()
env_setup_vm()
region_alloc()
load_icode()
env_create()
env_run()
</code></pre>

<p>env_init:</p>
<pre><code class="c">void
env_init(void)
{
    int i;
    for (i = NENV-1;i &gt;= 0; --i) {
    //initialize backwards to maintain the order
        envs[i].env_id = 0;
        //normal link-list routine
        envs[i].env_link = env_free_list;
        env_free_list = envs+i;
    }
    env_init_percpu();
}
</code></pre>

<p>env_setup_vm:</p>
<pre><code class="c">static int
env_setup_vm(struct Env *e)
{
    int i;
    struct PageInfo *p = NULL;
    if (!(p = page_alloc(ALLOC_ZERO)))
        return -E_NO_MEM;
    p-&gt;pp_ref++;    //reference count
    e-&gt;env_pgdir = (pde_t *) page2kva(p);
    memcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE);
    //we can just copy pgdir because everything is kern_gpdir is static
    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;
    return 0;
}
</code></pre>

<p>region_alloc:</p>
<pre><code class="c">static void
region_alloc(struct Env *e, void *va, size_t len)
{
    void *begin = ROUNDDOWN(va, PGSIZE), *end = ROUNDUP(va+len, PGSIZE);
    //round to align
    for (; begin &lt; end; begin += PGSIZE) {
        struct PageInfo *pg = page_alloc(0);    //not initialized
        if (!pg) panic("region_alloc failed!");
        page_insert(e-&gt;env_pgdir, pg, begin, PTE_W | PTE_U);
    }
}
</code></pre>

<pre><code class="c">
static void
load_icode(struct Env *e, uint8_t *binary, size_t size)
{
    struct Elf *ELFHDR = (struct Elf *) binary;
    struct Proghdr *ph, *eph;

    if (ELFHDR-&gt;e_magic != ELF_MAGIC)
        panic("Not executable!");

    ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);
    eph = ph + ELFHDR-&gt;e_phnum;

    //here above is just as same as main.c

    lcr3(PADDR(e-&gt;env_pgdir));
    //it's silly to use kern_pgdir here.

    for (; ph &lt; eph; ph++)
        if (ph-&gt;p_type == ELF_PROG_LOAD) {
            region_alloc(e, (void *)ph-&gt;p_va, ph-&gt;p_memsz);
            memset((void *)ph-&gt;p_va, 0, ph-&gt;p_memsz);
            memcpy((void *)ph-&gt;p_va, binary+ph-&gt;p_offset, ph-&gt;p_filesz);
        }

    //we can use this because kern_pgdir is a subset of e-&gt;env_pgdir
    lcr3(PADDR(kern_pgdir));

    e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;
    //we should set eip to make sure env_pop_tf runs correctly

    region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);
}
</code></pre>

<p>env_create, simple:</p>
<pre><code class="c">void
env_create(uint8_t *binary, size_t size, enum EnvType type)
{
    struct Env *penv;
    env_alloc(&amp;penv, 0);
    load_icode(penv, binary, size);
}
</code></pre>

<p>env_run, simply follow the guidelines:</p>
<pre><code class="c">void
env_run(struct Env *e)
{
    if (e-&gt;env_status == ENV_RUNNING)
        e-&gt;env_status = ENV_RUNNABLE;
    curenv = e;
    e-&gt;env_status = ENV_RUNNING;
    e-&gt;env_runs++;
    lcr3(PADDR(e-&gt;env_pgdir));
    env_pop_tf(&amp;e-&gt;env_tf);
}
</code></pre>

<p>Now use gdb to see if it works well:</p>
<pre><code>+ symbol-file obj/kern/kernel
(gdb) b env_pop_tf
Breakpoint 1 at 0xf01038de: file kern/env.c, line 456.
(gdb) c
Continuing.
The target architecture is assumed to be i386
=&gt; 0xf01038de &lt;env_pop_tf&gt;: push   %ebp

Breakpoint 1, env_pop_tf (tf=0xf01a1000) at kern/env.c:456
456 {
(gdb) s
=&gt; 0xf01038e4 &lt;env_pop_tf+6&gt;:   mov    0x8(%ebp),%esp
(gdb) si
=&gt; 0xf01038e7 &lt;env_pop_tf+9&gt;:   popa   
(gdb) 
=&gt; 0xf01038e8 &lt;env_pop_tf+10&gt;:  pop    %es
(gdb) 
=&gt; 0xf01038e9 &lt;env_pop_tf+11&gt;:  pop    %ds
(gdb) 
=&gt; 0xf01038ea &lt;env_pop_tf+12&gt;:  add    $0x8,%esp
(gdb) 
=&gt; 0xf01038ed &lt;env_pop_tf+15&gt;:  iret   
(gdb) 
=&gt; 0x800020:    cmp    $0xeebfe000,%esp
0x00800020 in ?? ()
(gdb) 
=&gt; 0x800026:    jne    0x80002c
0x00800026 in ?? ()
(gdb) 
=&gt; 0x800028:    push   $0x0
0x00800028 in ?? ()
(gdb) 
=&gt; 0x80002a:    push   $0x0
0x0080002a in ?? ()
(gdb) 
</code></pre>

<p>So far so good, let's move on.</p>
<h2 id="exercise-4">Exercise 4</h2>
<pre><code>Exercise 4. Edit trapentry.S and trap.c and implement the features described above. The macros TRAPHANDLER and TRAPHANDLER_NOEC in trapentry.S should help you, as well as the T_* defines in inc/trap.h. You will need to add an entry point in trapentry.S (using those macros) for each trap defined in inc/trap.h, and you'll have to provide _alltraps which the TRAPHANDLER macros refer to. You will also need to modify trap_init() to initialize the idt to point to each of these entry points defined in trapentry.S; the SETGATE macro will be helpful here.

Your _alltraps should:

push values to make the stack look like a struct Trapframe
load GD_KD into %ds and %es
pushl %esp to pass a pointer to the Trapframe as an argument to trap()
call trap (can trap ever return?)
Consider using the pushal instruction; it fits nicely with the layout of the struct Trapframe.

Test your trap handling code using some of the test programs in the user directory that cause exceptions before making any system calls, such as user/divzero. You should be able to get make grade to succeed on the divzero, softint, and badsegment tests at this point.
</code></pre>

<p>Here's the infomation about whether CPU pushes EC to the stack quoted from the i386 reference:</p>
<pre><code>Table 9-7. Error-Code Summary

Description                       Interrupt     Error Code
Number

Divide error                       0            No
Debug exceptions                   1            No
Breakpoint                         3            No
Overflow                           4            No
Bounds check                       5            No
Invalid opcode                     6            No
Coprocessor not available          7            No
System error                       8            Yes (always 0)
Coprocessor Segment Overrun        9            No
Invalid TSS                       10            Yes
Segment not present               11            Yes
Stack exception                   12            Yes
General protection fault          13            Yes
Page fault                        14            Yes
Coprocessor error                 16            No
Two-byte SW interrupt             0-255         No
</code></pre>

<p>So just add corresponding function generator in the text segment:</p>
<pre><code>/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
    TRAPHANDLER_NOEC(th0, 0)
    TRAPHANDLER_NOEC(th1, 1)
    TRAPHANDLER_NOEC(th3, 3)
    TRAPHANDLER_NOEC(th4, 4)
    TRAPHANDLER_NOEC(th5, 5)
    TRAPHANDLER_NOEC(th6, 6)
    TRAPHANDLER_NOEC(th7, 7)
    TRAPHANDLER(th8, 8)
    TRAPHANDLER_NOEC(th9, 9)
    TRAPHANDLER(th10, 10)
    TRAPHANDLER(th11, 11)
    TRAPHANDLER(th12, 12)
    TRAPHANDLER(th13, 13)
    TRAPHANDLER(th14, 14)
    TRAPHANDLER_NOEC(th16, 16)
</code></pre>

<p>And according to <code>inc/trap.h</code>, we should push %ds %es after <code>tf_trapno</code> is pushed:</p>
<pre><code class="c">struct Trapframe {
    struct PushRegs tf_regs;
    uint16_t tf_es;
    uint16_t tf_padding1;
    uint16_t tf_ds;
    uint16_t tf_padding2;
    uint32_t tf_trapno;
    /* below here defined by x86 hardware */
    uint32_t tf_err;
    uintptr_t tf_eip;
    uint16_t tf_cs;
    uint16_t tf_padding3;
    uint32_t tf_eflags;
    /* below here only when crossing rings, such as from user to kernel */
    uintptr_t tf_esp;
    uint16_t tf_ss;
    uint16_t tf_padding4;
} __attribute__((packed));
</code></pre>

<p>and then load GD_KD into %ds and %es</p>
<pre><code>_alltraps:
    pushl %ds
    pushl %es
    pushal
    pushl $GD_KD
    popl %ds
    pushl $GD_KD
    popl %es
    pushl %esp
    call trap
</code></pre>

<p>and set corresponding idt entries to install the handlers:</p>
<pre><code>void
trap_init(void)
{
    extern struct Segdesc gdt[];

    // LAB 3: Your code here.
    void th0();
    void th1();
    void th3();
    void th4();
    void th5();
    void th6();
    void th7();
    void th8();
    void th9();
    void th10();
    void th11();
    void th12();
    void th13();
    void th14();
    void th16();
    SETGATE(idt[0], 0, GD_KT, th0, 0);
    SETGATE(idt[1], 0, GD_KT, th1, 0);
    SETGATE(idt[3], 0, GD_KT, th3, 0);
    SETGATE(idt[4], 0, GD_KT, th4, 0);
    SETGATE(idt[5], 0, GD_KT, th5, 0);
    SETGATE(idt[6], 0, GD_KT, th6, 0);
    SETGATE(idt[7], 0, GD_KT, th7, 0);
    SETGATE(idt[8], 0, GD_KT, th8, 0);
    SETGATE(idt[9], 0, GD_KT, th9, 0);
    SETGATE(idt[10], 0, GD_KT, th10, 0);
    SETGATE(idt[11], 0, GD_KT, th11, 0);
    SETGATE(idt[12], 0, GD_KT, th12, 0);
    SETGATE(idt[13], 0, GD_KT, th13, 0);
    SETGATE(idt[14], 0, GD_KT, th14, 0);
    SETGATE(idt[16], 0, GD_KT, th16, 0);

    // Per-CPU setup 
    trap_init_percpu();
}
</code></pre>

<p>Type <code>make grade</code> and it gives:</p>
<pre><code>divzero: OK (5.2s) 
softint: OK (4.6s) 
    (Old jos.out.softint failure log removed)
badsegment: OK (4.6s) 
Part A score: 30/30
</code></pre>

<h2 id="challenge">Challenge</h2>
<pre><code>Challenge! You probably have a lot of very similar code right now, between the lists of TRAPHANDLER in trapentry.S and their installations in trap.c. Clean this up. Change the macros in trapentry.S to automatically generate a table for trap.c to use. Note that you can switch between laying down code and data in the assembler by using the directives .text and .data.
</code></pre>

<p>Let's define a function array in <code>trapentry.S</code>:</p>
<pre><code>.data
    .p2align 2
    .globl funs
funs:
</code></pre>

<p>so we can just use a <code>for</code> loop to install the handler funcionts:</p>
<pre><code class="c">void
trap_init(void)
{
    extern struct Segdesc gdt[];
    // Challenge:
    extern void (*funs[])();
    void (*fun)() = funs[0];
    cprintf("%p\n", fun);
    int i;
    for (i = 0; i &lt;= 16; ++i)
        if (i!=2 &amp;&amp; i!=15) {
            SETGATE(idt[i], 0, GD_KT, funs[i], 0);
        }
    // Per-CPU setup 
    trap_init_percpu();
}
</code></pre>

<p>We have to define our own macro <code>noec</code> and <code>ec</code>, for example, every time a <code>noec</code> is called, <code>text</code> segment defines a funtion and <code>data</code> segment increase 4-byte to save the function entry:</p>
<pre><code>#define noec(name, num)\
.data;\
    .long name;\
.text;\
    .globl name;\
    .type name, @function;\
    .align 2;\
name:\
    pushl $0;\
    pushl $(num);\
    jmp _alltraps
</code></pre>

<p>and then the main definition should be like this:</p>
<pre><code>.text
/*
 * Challenge: my code here
 */
    noec(th0, 0)
    noec(th1, 1)
    #no 2 here
    noec(th3, 3)
    noec(th4, 4)
    noec(th5, 5)
    noec(th6, 6)
    noec(th7, 7)
    noec(th9, 9)
    ec(th10, 10)
    ec(th11, 11)
    ec(th12, 12)
    ec(th13, 13)
    ec(th14, 14)
    #no 15 here
    noec(th16, 16)
</code></pre>

<p>But unfortunately it's wrong and it takes me one hour to figure out why, because the code <code>noec(th3, 3)</code> will install the <code>funs[2]</code> entry rather than the third one thus makes a bloody shift in the array(another shift if <code>noec(16, 16)</code>), so we have to fix it by adding paddings:</p>
<pre><code>#define zhanwei()\
.data;\
    .long 0

...

.text
/*
 * Challenge: my code here
 */
    noec(th0, 0)
    noec(th1, 1)
    zhanwei()
    noec(th3, 3)
    noec(th4, 4)
    noec(th5, 5)
    noec(th6, 6)
    noec(th7, 7)
    ec(th8, 8)
    noec(th9, 9)
    ec(th10, 10)
    ec(th11, 11)
    ec(th12, 12)
    ec(th13, 13)
    ec(th14, 14)
    zhanwei()
    noec(th16, 16)
</code></pre>

<p>then it correctly passes the grading script (you can't imagine how ugly is <code>trapentry.S</code> now).</p>
<h2 id="questions">Questions</h2>
<pre><code>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
</code></pre>

<p>We can't easily provide protection then.</p>
<pre><code>Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?
</code></pre>

<p>We should set the dpl to 3 to allow users invoke <code>int $14</code>:</p>
<pre><code>SETGATE(idt[i], 0, GD_KT, funs[i], 3);
</code></pre>

<p>but this will let user interfere with memory management which is not what we want.</p>
<h2 id="this-finishes-part-a">This finishes Part A</h2>
<h2 id="part-b-page-faults-breakpoints-exceptions-and-system-calls">Part B: Page Faults, Breakpoints Exceptions, and System Calls</h2>
<h2 id="exercise-5">Exercise 5</h2>
<pre><code>Exercise 5. Modify trap_dispatch() to dispatch page fault exceptions to page_fault_handler(). You should now be able to get make grade to succeed on the faultread, faultreadkernel, faultwrite, and faultwritekernel tests. If any of them don't work, figure out why and fix them. Remember that you can boot JOS into a particular user program using make run-x or make run-x-nox.
</code></pre>

<p>Just add this to <code>trap_dispatch</code>:</p>
<pre><code class="c">    // LAB 3: Your code here.
    if (tf-&gt;tf_trapno == T_PGFLT) {
        page_fault_handler(tf);
        return;
    }
</code></pre>

<p>and then we can get <code>50/80</code> grades by <code>make grade</code>.</p>
<h2 id="exercise-6">Exercise 6</h2>
<pre><code>Exercise 6. Modify trap_dispatch() to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the breakpoint test.
</code></pre>

<p>Again we can just add an <code>if</code> to <code>trap.c</code>:</p>
<pre><code class="c">if (tf-&gt;tf_trapno == T_BRKPT) {
    monitor(tf);
    return;
}
</code></pre>

<p>and we also have to modify the <code>dpl</code> of <code>T_BRKPT</code> to allow users to invoke breakpoint exceptions:</p>
<pre><code class="c">for (i = 0; i &lt;= 16; ++i)
    if (i==T_BRKPT)
        SETGATE(idt[i], 0, GD_KT, funs[i], 3)
    else if (i!=2 &amp;&amp; i!=15) {
        SETGATE(idt[i], 0, GD_KT, funs[i], 0);
    }
</code></pre>

<h2 id="challenge_1">Challenge</h2>
<pre><code>Challenge! Modify the JOS kernel monitor so that you can 'continue' execution from the current location (e.g., after the int3, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the EFLAGS register in order to implement single-stepping
</code></pre>

<p>Maybe I'll do this later...</p>
<h2 id="questions_1">Questions</h2>
<pre><code>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?
</code></pre>

<p>Just set the <code>dpl</code> that enables user-invoking.</p>
<pre><code>What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
</code></pre>

<p>Protection.</p>
<h2 id="exercise-7">Exercise 7</h2>
<pre><code>Exercise 7. Add a handler in the kernel for interrupt vector T_SYSCALL. You will have to edit kern/trapentry.S and kern/trap.c's trap_init(). You also need to change trap_dispatch() to handle the system call interrupt by calling syscall() (defined in kern/syscall.c) with the appropriate arguments, and then arranging for the return value to be passed back to the user process in %eax. Finally, you need to implement syscall() in kern/syscall.c. Make sure syscall() returns -E_INVAL if the system call number is invalid. You should read and understand lib/syscall.c (especially the inline assembly routine) in order to confirm your understanding of the system call interface. You may also find it helpful to read inc/syscall.h.
</code></pre>

<p>Just be aware of the arguments:</p>
<pre><code class="c">int32_t
syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
    int ret = 0;
    switch (syscallno) {
        case SYS_cputs: 
            sys_cputs((char*)a1, a2);
            ret = 0;
            break;
        case SYS_cgetc:
            ret = sys_cgetc();
            break;
        case SYS_getenvid:
            ret = sys_getenvid();
            break;
        case SYS_env_destroy:
            sys_env_destroy(a1);
            ret = 0;
            break;
        default:
            ret = -E_INVAL;
    }
    // cprintf("ret: %x\n", ret);
    return ret;
    panic("syscall not implemented");
}
</code></pre>

<p>Here's the tricky point, we have to assign the <code>syscall</code> return value to <code>tf-&gt;tf_regs.reg_eax</code> as the return value of the trap (well, another hour to figure it out when doing exercise 8):</p>
<pre><code class="c">tf-&gt;tf_regs.reg_eax = 
    syscall(tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx,
            tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);
</code></pre>

<pre><code class="c">static void
trap_dispatch(struct Trapframe *tf)
{
    // Handle processor exceptions.
    // LAB 3: Your code here.
    if (tf-&gt;tf_trapno == T_PGFLT) {
        cprintf("PAGE FAULT\n");
        page_fault_handler(tf);
        return;
    }
    if (tf-&gt;tf_trapno == T_BRKPT) {
        cprintf("BREAK POINT\n");
        monitor(tf);
        return;
    }
    if (tf-&gt;tf_trapno == T_SYSCALL) {
        cprintf("SYSTEM CALL\n");
        tf-&gt;tf_regs.reg_eax = 
            syscall(tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx,
                tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);
        return;
    }
    // Unexpected trap: The user process or the kernel has a bug.
    print_trapframe(tf);
    if (tf-&gt;tf_cs == GD_KT)
        panic("unhandled trap in kernel");
    else {
        env_destroy(curenv);
        return;
    }
}
</code></pre>

<h2 id="exercise-8">Exercise 8</h2>
<pre><code>Exercise 8. Add the required code to the user library, then boot your kernel. You should see user/hello print "hello, world" and then print "i am environment 00001000". user/hello then attempts to "exit" by calling sys_env_destroy() (see lib/libmain.c and lib/exit.c). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the hello test.
</code></pre>

<p>Just one line <code>thisenv = envs+ENVX(sys_getenvid());</code> in libmain</p>
<h2 id="exercise-9">Exercise 9</h2>
<pre><code>Exercise 9. Change kern/trap.c to panic if a page fault happens in kernel mode.

Hint: to determine whether a fault happened in user mode or in kernel mode, check the low bits of the tf_cs.

Read user_mem_assert in kern/pmap.c and implement user_mem_check in that same file.

Change kern/syscall.c to sanity check arguments to system calls.

Boot your kernel, running user/buggyhello. The environment should be destroyed, and the kernel should not panic. You should see:

    [00001000] user_mem_check assertion failure for va 00000001
    [00001000] free env 00001000
    Destroyed the only environment - nothing more to do!

</code></pre>

<p>Just panic when page fault occur in kernel mode:</p>
<pre><code class="c">    if ((tf-&gt;tf_cs&amp;3) == 0)
        panic("Kernel page fault!");
</code></pre>

<p>In <code>user_mem_check</code>, we should first test whether <code>i</code> is above ULIM, test whether <code>pte</code> and <code>*pte</code> is valid, then the <code>perm</code>:</p>
<pre><code class="c">int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
    // LAB 3: Your code here.
    cprintf("user_mem_check va: %x, len: %x\n", va, len);
    uint32_t begin = (uint32_t) ROUNDDOWN(va, PGSIZE); 
    uint32_t end = (uint32_t) ROUNDUP(va+len, PGSIZE);
    uint32_t i;
    for (i = (uint32_t)begin; i &lt; end; i+=PGSIZE) {
        pte_t *pte = pgdir_walk(env-&gt;env_pgdir, (void*)i, 0);
        pprint(pte);
        if ((i&gt;=ULIM) || !pte || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm)) {
            user_mem_check_addr = (i&lt;(uint32_t)va?(uint32_t)va:i);
            return -E_FAULT;
        }
    }
    cprintf("user_mem_check success va: %x, len: %x\n", va, len);
    return 0;
}
</code></pre>

<pre><code>Finally, change debuginfo_eip in kern/kdebug.c to call user_mem_check on usd, stabs, and stabstr. If you now run user/breakpoint, you should be able to run backtrace from the kernel monitor and see the backtrace traverse into lib/libmain.c before the kernel panics with a page fault. What causes this page fault? You don't need to fix it, but you should understand why it happens.
</code></pre>

<p>Add the checking code to the <code>kdebug.c</code> to avoid kernel page fault:</p>
<pre><code class="c">    if (user_mem_check(curenv, usd, sizeof(struct UserStabData), PTE_U))
        return -1;

    ...

    if (user_mem_check(curenv, stabs, sizeof(struct Stab), PTE_U))
        return -1;

    if (user_mem_check(curenv, stabstr, stabstr_end-stabstr, PTE_U))
        return -1;
</code></pre>

<p>When I call <code>backtrace</code> I get a <code>PAGE FAULT</code>, it is easy to see that the PF is caused by accessing memory <code>0xeebfe000</code>, which is beyond the user stack:</p>
<pre><code>K&gt; csa_backtrace
Stack backtrace:
ebp efffff00  eip f0100a44  args 00000001 efffff28 f01a2000 00000200 f0105675
         kern/monitor.c:177: monitor+337
ebp efffff80  eip f010402a  args f01a2000 efffffbc 00000014 00000000 00000000
         kern/trap.c:197: trap+207
ebp efffffb0  eip f0104147  args efffffbc 00000000 00000000 eebfdfd0 efffffdc
         kern/trapentry.S:114: &lt;unknown&gt;+0
ebp eebfdfd0  eip 80007f  args 00000000 00000000 00000000 00000000 00000000
         lib/libmain.c:30: libmain+67
ebp eebfdff0  eip 800031  args 00000000 00000000Incoming TRAP frame at 0xeffffe6c
PAGE FAULT
</code></pre>

<h2 id="exercise-10">Exercise 10</h2>
<pre><code>Exercise 10. Boot your kernel, running user/evilhello. The environment should be destroyed, and the kernel should not panic. You should see:

    [00000000] new env 00001000
    [00001000] user_mem_check assertion failure for va f0100020
    [00001000] free env 00001000
</code></pre>

<p>This test passes automaticly after Exercise 9 is finished.</p>
<h1 id="this-completes-the-lab">This completes the lab.</h1></body></html>